class Solution(object):
    """ Wrong. """
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = []
        for p1, num1 in enumerate(nums):
            if p1 != 0 and nums[p1] == nums[p1-1]:
                continue
            p2 = p1 + 1; p3 = len(nums) - 1
            while p2 < p3:
                num2 = nums[p2]; num3 = nums[p3]
                cur_sum = num1 + num2 + num3
                if cur_sum == 0:
                    res.append([num1, num2, num3])
                    p2 += 1; p3 -= 1
                    while p2 < p3 and nums[p2] == nums[p2-1]: p2 += 1
                    while p2 < p3 and nums[p3] == nums[p3+1]: p3 -= 1
                elif cur_sum < 0:
                    p2 += 1
                else:
                    p3 -= 1
        return res
        
class Solution(object):
    """ Two Pointers.
    Pay attention to corner cases of duplicate numbers. """
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = []
        nums.sort()
        for p1, num1 in enumerate(nums):
            if p1 != 0 and nums[p1] == nums[p1-1]:
                continue
            p2 = p1 + 1; p3 = len(nums) - 1
            while p2 < p3:
                num2 = nums[p2]; num3 = nums[p3]
                cur_sum = num1 + num2 + num3
                if cur_sum == 0:
                    res.append([num1, num2, num3])
                    p2 += 1; p3 -= 1
                    while p2 < p3 and nums[p2] == nums[p2-1]: p2 += 1
                    while p2 < p3 and nums[p3] == nums[p3+1]: p3 -= 1
                elif cur_sum < 0:
                    p2 += 1
                else:
                    p3 -= 1
        return res
        
class Solution(object):
    """ Small changes to optimize speed. """
    def threeSum(self, nums):
        """
        :type nums: List[int]
        :rtype: List[List[int]]
        """
        res = []
        nums.sort()
        for p1, num1 in enumerate(nums):
            if num1 > 0:
                break
            if p1 != 0 and nums[p1] == nums[p1-1]:
                continue
            p2 = p1 + 1; p3 = len(nums) - 1
            while p2 < p3:
                num2 = nums[p2]; num3 = nums[p3]
                cur_sum = num1 + num2 + num3
                if cur_sum == 0:
                    res.append([num1, num2, num3])
                    p2 += 1; p3 -= 1
                    while p2 < p3 and nums[p2] == nums[p2-1]: p2 += 1
                    while p2 < p3 and nums[p3] == nums[p3+1]: p3 -= 1
                elif cur_sum < 0:
                    p2 += 1
                else:
                    p3 -= 1
        return res
                    
                    
                    
